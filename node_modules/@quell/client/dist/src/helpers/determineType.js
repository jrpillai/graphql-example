"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const visitor_1 = require("graphql/language/visitor");
/**
 * Traverses the abstract syntax tree depth-first to determine which operations types are 'unQuellable' along the AST.
 * @param {Object} AST - Abstract syntax tree generated by GraphQL library.
 * @returns {Object} Object containing operation type is 'unQuellable' and prototype object.
 */
function determineType(AST) {
    // Initialize an array to keep track of the field names in the AST.
    let fieldNames = [];
    // Initialize a prototype object which will be populated with information extracted from the AST.
    const proto = {};
    // Initialize a frags object to keep track of the fragments in the query.
    const frags = {};
    // Initialize an arguments object to store the arguments in the current node.
    const argsObj = {};
    // Declare a targetObj which will be used to point to prototype when iterating through Field nodes 
    // and to point to frags when iterating through Fragment Definition nodes.
    let targetObj;
    // Initialize operationType which will hold the type of operation ('query', 'mutation', 'subscription', etc.).
    let operationType = '';
    // Initialize a stack to keep track of nodes while traversing the AST in depth-first order.
    const stack = [];
    // Initialize variable to keep track of depth of selection set in the AST.
    let selectionSetDepth = 0;
    // Initialize an object to keep track of the id, type, alias, and args for the fields.
    // The field arguments object will eventually be merged with the prototype object.
    const fieldArgs = {};
    // Initialize a variable to keep track of depth in the AST.
    let depth = 0;
    /**
     * visit is a utility provided in the graphql-JS library. It performs a depth-first traversal of the abstract
     * syntax tree, invoking a callback when each SelectionSet node is entered. That function builds the prototype.
     * Invokes a callback when entering and leaving Field node to keep track of nodes with stack.
     * Find documentation at: https://graphql.org/graphql-js/language/#visit
     */
    (0, visitor_1.visit)(AST, {
        // The enter function will be triggered upon entering each node in the traversal.
        enter(node) {
            var _a, _b;
            // Quell cannot cache directives, so we need to return as unQuellable if the node has directives.
            if (node === null || node === void 0 ? void 0 : node.directives) {
                if ((_b = (_a = node === null || node === void 0 ? void 0 : node.directives) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0 > 0) {
                    operationType = 'unQuellable';
                    // Return BREAK to break out of the current traversal branch.
                    return visitor_1.BREAK;
                }
            }
        },
        // If the current node is of type OperationDefinition, this function will be triggered upon entering it.
        // It checks the type of operation being performed.
        OperationDefinition(node) {
            targetObj = proto;
            // Quell cannot cache subscriptions, so we need to return as unQuellable if the type is subscription.
            operationType = node.operation;
            if (operationType === 'subscription') {
                operationType = 'unQuellable';
                // Return BREAK to break out of the current traversal branch.
                return visitor_1.BREAK;
            }
        },
        // If the current node is of type FragmentDefinition, this function will be triggered upon entering it.
        FragmentDefinition: {
            enter(node) {
                // Get the name of the fragment.
                const fragName = node.name.value;
                // Add the fragment name to the stack.
                stack.push(fragName);
                // Add the fragment name as a key in target object (which will be frags while inside the loop below), initialized to an empty object.
                targetObj = frags;
                targetObj[fragName] = {};
                // Loop through the selections in the selection set for the current FragmentDefinition node in order to extract the fields in the fragment.
                for (let i = 0; i < node.selectionSet.selections.length; i++) {
                    // Skip nodes of type 'InlineFragment' as they don't have a 'name' property.
                    if (node.selectionSet.selections[i].kind !== 'InlineFragment') {
                        // Add base-level field names in the fragment to the frags (aka target) object.
                        targetObj[fragName][node.selectionSet.selections[i].name.value] = true;
                    }
                }
            },
            // If the current node is of type FragmentDefinition, this function will be triggered after visiting it and all of its children.
            leave() {
                // Pop stacks to keep track of depth-first parsing path.
                stack.pop();
            }
        },
        Field: {
            // If the current node is of type Field, this function will be triggered upon entering it.
            enter(node) {
                // Increment depth if the node has a selection set.
                if (node.selectionSet)
                    depth++;
                // Return introspection queries as 'unQuellable' to prevent caching.
                // "__keyname" syntax is later used for Quell's field-specific options, though this does not create collision with introspection.
                // Fields with names including '__' are excluded from caching.
                if (node.name.value.includes('__')) {
                    operationType = 'unQuellable';
                    // Return BREAK to break out of the current traversal branch.
                    return visitor_1.BREAK;
                }
                // Loop through the field's arguments.
                if (node.arguments) {
                    node.arguments.forEach((arg) => {
                        const key = arg.name.value;
                        // Quell cannot cache queries with variables, so we need to return unQuellable if the query has variables.
                        if (arg.value.kind === 'Variable' && operationType === 'query') {
                            operationType = 'unQuellable';
                            // Return BREAK to break out of the current traversal branch.
                            return visitor_1.BREAK;
                        }
                        /**
                         * In the next step, we get the value from the argument node's value node. This assumes that the value
                         * node has a 'value' property. If the 'kind' of the value node is ObjectValue, ListValue, NullValue,
                         * or ListValue then the value node will not have a 'value' property, so we must first check that
                         * the 'kind' does not match any of those types.
                         */
                        if (arg.value.kind === 'NullValue' || arg.value.kind === 'ObjectValue' || arg.value.kind === 'ListValue') {
                            operationType = 'unQuellable';
                            // Return BREAK to break out of the current traversal branch.
                            return visitor_1.BREAK;
                        }
                        // Assign argument values to argsObj (key will be argument name, value will be argument value),
                        // skipping field-specific options ('__') provided as arguments.
                        if (!key.includes('__')) {
                            argsObj[key] = arg.value.value;
                        }
                    });
                }
                // Set the fieldType equal to either the field's alias or the field's name.
                const fieldType = node.alias
                    ? node.alias.value
                    : node.name.value;
                // Add the field type to the stack to keep track of depth-first parsing path.
                stack.push(fieldType);
                // If the field has a name and is at depth greater than 1, add it to fieldNames.
                if ((node.name && node.name.value && depth > 1 && node.selectionSet) || (selectionSetDepth === 1 && depth === 1)) {
                    fieldNames.push(node.name.value);
                }
            },
            // If the current node is of type 'Field', this function will be triggered after visiting it and all of its children.
            leave(node) {
                // Decrement depth if the node has a selection set.
                if (node.selectionSet)
                    depth--;
                // Pop stacks to keep track of depth-first parsing path.
                stack.pop();
            }
        },
        SelectionSet: {
            // If the current node is of type SelectionSet, this function will be triggered upon entering it.
            // The selection sets contain all of the sub-fields. Iterate through the sub-fields to construct fieldsObject
            enter(node, key, parent, path, ancestors) {
                selectionSetDepth++;
                /**
                 * Exclude SelectionSet nodes whose parents are not of the kind 'Field'
                 * to exclude nodes that do not contain information about queried fields.
                 */
                if (parent && // parent is not undefined
                    !Array.isArray(parent) && // parent is not readonly ASTNode[]
                    parent.kind === 'Field' // can now safely assume that parent will have 'kind' property
                ) {
                    // Create a 'fieldsValues' object to collect fields as we loop through the selections.
                    const fieldsValues = {};
                    for (const field of node.selections) {
                        /**
                         * If the current selection in the selections array is not a nested object
                         * (i.e., does not have a SelectionSet), set its value in 'fieldsValues' to true.
                         * Note: InlineFragmentNode (one of the possible types for SelectionNode) does not
                         * have a 'name' property, so we skip nodes with that type.
                         * Furthermore, FragmentSpreadNodes never have a selection set property.
                        */
                        if (field.kind !== 'InlineFragment' &&
                            (field.kind === 'FragmentSpread' || !field.selectionSet))
                            fieldsValues[field.name.value] = true;
                    }
                    // If the request does not include 'id' and the current node is not a fragment,
                    // mark the operation as 'unQuellable' as the query will not be included in the cache.
                    if (!Object.prototype.hasOwnProperty.call(fieldsValues, 'id') &&
                        !Object.prototype.hasOwnProperty.call(fieldsValues, '_id') &&
                        !Object.prototype.hasOwnProperty.call(fieldsValues, 'ID') &&
                        !Object.prototype.hasOwnProperty.call(fieldsValues, 'Id')) {
                        operationType = 'unQuellable';
                        // Return 'BREAK' to break out of the current traversal branch.
                        return visitor_1.BREAK;
                    }
                    // Place current fieldArgs object onto fieldsObject so it gets passed along to prototype.
                    // The fieldArgs contains arguments, aliases, etc.
                    const fieldsObject = Object.assign(Object.assign({}, fieldsValues), fieldArgs[stack[stack.length - 1]]);
                    // Loop through the stack to get the correct path in 'proto' for the temporary object.
                    // This mutation updates the original prototype object with values from the temporary object.
                    stack.reduce((prev, curr, index) => {
                        // If it's the last item in the path, set the value.
                        if (index + 1 === stack.length)
                            prev[curr] = Object.assign({}, fieldsObject);
                        return prev[curr];
                    }, targetObj);
                }
            },
            leave() {
                // Decrement the depth of the selection set as we leave the node.
                selectionSetDepth--;
            }
        }
    });
    fieldNames = [...new Set(fieldNames)];
    return { operationType, proto, fieldNames };
}
exports.default = determineType;

import { Response, Request, NextFunction } from "express";
import { RedisClientType } from "redis";
import { GraphQLSchema, ExecutionResult } from "graphql";
import { ConstructorOptions, IdCacheType, CostParamsType, ProtoObjType, MutationMapType, QueryMapType, FieldsMapType, ItemFromCacheType, ResponseDataType, QueryFields, DatabaseResponseDataRaw, Type, RequestType } from "./types";
/**
 * Creates a QuellCache instance that provides middleware for caching between the graphQL endpoint and
 * front-end requests, connects to redis cloud store via user-specified parameters.
 *    - If there is no cache expiration provided by the user, cacheExpiration defaults to 14 days in seconds.
 *    - If there are no cost parameters provided by the user, costParameters is given the default values.
 *    - If redisPort, redisHost, and redisPassword are omitted, will use local Redis instance.
 *     See https://redis.io/docs/getting-started/installation/ for instructions on installing Redis and starting a Redis server.
 *  @param {ConstructorOptions} options - The options to use for the cache.
 *  @param {GraphQLSchema} options.schema - GraphQL defined schema that is used to facilitate caching by providing valid queries,
 *  mutations, and fields.
 *  @param {number} [options.cacheExpiration=1209600] - Time in seconds for redis values to be evicted from the cache. Defaults to 14 days.
 *  @param {CostParamsType} [options.costParameters=defaultCostParams] - The cost parameters to use for caching. Defaults to:
 *    - maxCost: 5000 (maximum cost allowed before a request is rejected)
 *    - mutationCost: 5 (cost of a mutation)
 *    - objectCost: 2 (cost of retrieving an object)
 *    - scalarCost: 1 (cost of retrieving a scalar)
 *    - depthCostFactor: 1.5 (multiplicative cost of each depth level)
 *    - maxDepth: 10 (depth limit parameter)
 *    - ipRate: 3 (requests allowed per second)
 *  @param {number} options.redisPort - (optional) The Redis port to connect to.
 *  @param {string} options.redisHost - (optional) The Redis host URI to connect to.
 *  @param {string} options.redisPassword - (optional) The Redis password to the host URI.
 *  @example // Omit redisPort, redisHost, and redisPassword to use a local Redis instance.
 *  const quellCache = new QuellCache({
 *    schema: schema,
 *    cacheExpiration: 3600, // 1 hour in seconds
 *    });
 */
export declare class QuellCache {
    idCache: IdCacheType;
    schema: GraphQLSchema;
    costParameters: CostParamsType;
    queryMap: QueryMapType;
    mutationMap: MutationMapType;
    fieldsMap: FieldsMapType;
    cacheExpiration: number;
    redisReadBatchSize: number;
    redisCache: RedisClientType;
    constructor({ schema, cacheExpiration, // Default expiry time is 14 days in seconds
    costParameters, redisPort, redisHost, redisPassword, }: ConstructorOptions);
    /**
     * A redis-based IP rate limiter middleware function that limits the number of requests per second based on IP address using Redis.
     *  @param {Request} req - Express request object, including request body with GraphQL query string.
     *  @param {Response} res - Express response object, will carry query response to next middleware.
     *  @param {NextFunction} next - Express next middleware function, invoked when QuellCache completes its work.
     *  @returns {void} Passes an error to Express if no query was included in the request or if the number of requests by the current IP
     *  exceeds the IP rate limit.
     */
    rateLimiter(req: RequestType, res: Response, next: NextFunction): Promise<void>;
    /**
     * The class's controller method. It:
     *    - reads the query string from the request object,
     *    - tries to construct a response from cache,
     *    - reformulates a query for any data not in cache,
     *    - passes the reformulated query to the graphql library to resolve,
     *    - joins the cached and uncached responses,
     *    - decomposes and caches the joined query, and
     *    - attaches the joined response to the response object before passing control to the next middleware.
     *  @param {Request} req - Express request object, including request body with GraphQL query string.
     *  @param {Response} res - Express response object, will carry query response to next middleware.
     *  @param {NextFunction} next - Express next middleware function, invoked when QuellCache completes its work.
     */
    query(req: RequestType, res: Response, next: NextFunction): Promise<void>;
    /**
     * Finds any requested information in the cache and assembles it on the cacheResponse.
     * Uses the prototype as a template for cacheResponse and marks any data not found in the cache
     * on the prototype for future retrieval from database.
     * @param {Object} prototype - Unique id under which the cached data will be stored.
     * @param {Array} prototypeKeys - Keys in the prototype.
     * @param {Object} itemFromCache - Item to be cached.
     * @param {boolean} firstRun - Boolean indicated if this is the first run.
     * @param {boolean|string} subID - Used to pass id to recursive calls.
     * @returns {Object} cacheResponse, mutates prototype.
     */
    buildFromCache(prototype: ProtoObjType, prototypeKeys: string[], itemFromCache?: ItemFromCacheType, firstRun?: boolean, subID?: boolean | string): Promise<{
        data: ItemFromCacheType;
    }>;
    /**
     * Traverses over response data and formats it appropriately so that it can be stored in the cache.
     * @param {Object} responseData - Data we received from an external source of data such as a database or API.
     * @param {Object} map - Map of queries to their desired data types, used to ensure accurate and consistent caching.
     * @param {Object} protoField - Slice of the prototype currently being used as a template and reference for the responseData to send information to the cache.
     * @param {string} currName - Parent object name, used to pass into updateIDCache.
     */
    normalizeForCache(responseData: ResponseDataType, map: QueryMapType | undefined, protoField: ProtoObjType, currName: string): Promise<void>;
    /**
     * Helper function that creates cacheIDs based on information from the prototype in the
     * format of 'field--ID'.
     * @param {string} key - Unique id under which the cached data will be stored.
     * @param {Object} item - Item to be cached.
     */
    generateCacheID(queryProto: ProtoObjType): string;
    /**
     * Stringifies and writes an item to the cache unless the key indicates that the item is uncacheable.
     * Sets the expiration time for each item written to cache to the expiration time set on server connection.
     * @param {string} key - Unique id under which the cached data will be stored.
     * @param {Object} item - Item to be cached.
     */
    writeToCache(key: string, item: Type | string[] | ExecutionResult): void;
    /**
     * Stores keys in a nested object under parent name.
     * If the key is a duplication, it is stored in an array.
     *  @param {string} objKey - Object key; key to be cached without ID string.
     *  @param {string} keyWithID - Key to be cached with ID string attached; Redis data is stored under this key.
     *  @param {string} currName - The parent object name.
     */
    updateIdCache(objKey: string, keyWithID: string, currName: string): void;
    /**
     * Updates the Redis cache when the operation is a mutation.
     * - For update and delete mutations, checks if the mutation query includes an id.
     * If so, it will update the cache at that id. If not, it will iterate through the cache
     * to find the appropriate fields to update/delete.
     * @param {Object} dbRespDataRaw - Raw response from the database returned following mutation.
     * @param {string} mutationName - Name of the mutation (e.g. addItem).
     * @param {string} mutationType - Type of mutation (add, update, delete).
     * @param {Object} mutationQueryObject - Arguments and values for the mutation.
     */
    updateCacheByMutation(dbRespDataRaw: DatabaseResponseDataRaw | ExecutionResult, mutationName: string, mutationType: string, mutationQueryObject: QueryFields | ProtoObjType): Promise<void>;
    /**
     * Removes key-value from the cache unless the key indicates that the item is not available.
     * @param {string} key - Unique id under which the cached data is stored that needs to be removed.
     */
    deleteCacheById(key: string): Promise<void>;
    /**
     * Flushes the Redis cache. To clear the cache from the client, establish an endpoint that
     * passes the request and response objects to an instance of QuellCache.clearCache.
     * @param {Object} req - Express request object.
     * @param {Object} res - Express response object.
     * @param {Function} next - Express next middleware function.
     */
    clearCache(req: Request, res: Response, next: NextFunction): void;
    /**
     * Takes in the query, parses it, and identifies the general shape of the request in order
     * to compare the query's depth to the depth limit set on server connection.
     *
     * In the instance of a malicious or overly nested query, short-circuits the query before
     * it goes to the database and passes an error with a status code 413 (content too large).
     * @param {Object} req - Express request object
     * @param {Object} res - Express response object
     * @param {Function} next - Express next middleware function
     * @returns {void} Passes an error to Express if no query was included in the request or if the depth exceeds the maximum allowed depth.
     */
    depthLimit(req: Request, res: Response, next: NextFunction): void;
    /**
     * Checks the cost of the query. In the instance of a malicious or overly nested query,
     * short-circuits the query before it goes to the database and passes an error with a
     * status code 413 (content too large).
     * @param {Object} req - Express request object.
     * @param {Object} res - Express response object.
     * @param {Function} next - Express next middleware function.
     * @returns {void} Passes an error to Express if no query was included in the request or if the cost exceeds the maximum allowed cost.
     */
    costLimit(req: Request, res: Response, next: NextFunction): void;
}
